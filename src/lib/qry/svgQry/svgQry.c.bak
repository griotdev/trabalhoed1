#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <float.h>
#include <string.h>
#include "svgQry.h"
#include "../gameState/gameState.h"
#include "../disparador/disparador.h"
#include "../formaUtils/formaArena.h"
#include "../../formas/formas/formas.h"
#include "../../estruturas/fila/fila.h"
#include "../../geo/svg/svg.h"

// Função removida - não precisamos mais desenhar os disparadores

static void desenhaAnotacaoTrajetoria(FILE *arq, Forma *f, double disparadorX, double disparadorY)
{
    if (!f)
        return;
    
    // Obt\u00e9m posi\u00e7\u00e3o da forma
    TipoForma tipo = getFormaTipo(f);
    double formaX = 0.0, formaY = 0.0;
    
    switch (tipo)
    {
    case TIPO_CIRCULO:
    {
        Circulo c = (Circulo)getFormaDados(f);
        formaX = getCirculoX(c);
        formaY = getCirculoY(c);
        break;
    }
    case TIPO_RETANGULO:
    {
        Retangulo r = (Retangulo)getFormaDados(f);
        formaX = getRetanguloX(r);
        formaY = getRetanguloY(r);
        break;
    }
    case TIPO_LINHA:
    {
        Linha l = (Linha)getFormaDados(f);
        formaX = getLinhaX1(l);
        formaY = getLinhaY1(l);
        break;
    }
    case TIPO_TEXTO:
    {
        Texto t = (Texto)getFormaDados(f);
        formaX = getTextoX(t);
        formaY = getTextoY(t);
        break;
    }
    default:
        return;
    }
    
    // Calcula deslocamentos
    double dx = formaX - disparadorX;
    double dy = formaY - disparadorY;
    double midHx = disparadorX + dx * 0.5;
    double midHy = disparadorY;
    double midVx = formaX;
    double midVy = disparadorY + dy * 0.5;
    
    // Linha tracejada vermelha do disparador \u00e0 posi\u00e7\u00e3o final
    fprintf(arq, "  <line x1=\"%.2f\" y1=\"%.2f\" x2=\"%.2f\" y2=\"%.2f\" stroke=\"red\" stroke-dasharray=\"4,2\" stroke-width=\"1\"/>\n",
            disparadorX, disparadorY, formaX, formaY);
    
    // C\u00edrculo marcador vermelho na posi\u00e7\u00e3o final
    fprintf(arq, "  <circle cx=\"%.2f\" cy=\"%.2f\" r=\"3\" fill=\"none\" stroke=\"red\" stroke-width=\"1\"/>\n",
            formaX, formaY);
    
    // Guia horizontal (linha roxa tracejada)
    fprintf(arq, "  <line x1=\"%.2f\" y1=\"%.2f\" x2=\"%.2f\" y2=\"%.2f\" stroke=\"purple\" stroke-dasharray=\"2,2\" stroke-width=\"0.8\"/>\n",
            disparadorX, disparadorY, formaX, disparadorY);
    
    // Guia vertical (linha roxa tracejada)
    fprintf(arq, "  <line x1=\"%.2f\" y1=\"%.2f\" x2=\"%.2f\" y2=\"%.2f\" stroke=\"purple\" stroke-dasharray=\"2,2\" stroke-width=\"0.8\"/>\n",
            formaX, disparadorY, formaX, formaY);
    
    // Label dx acima da guia horizontal
    fprintf(arq, "  <text x=\"%.2f\" y=\"%.2f\" fill=\"purple\" font-size=\"12\" text-anchor=\"middle\">dx=%.1f</text>\n",
            midHx, midHy - 5.0, dx);
    
    // Label dy rotacionado pr\u00f3ximo \u00e0 guia vertical
    fprintf(arq, "  <text x=\"%.2f\" y=\"%.2f\" fill=\"purple\" font-size=\"12\" text-anchor=\"middle\" transform=\"rotate(-90 %.2f %.2f)\">dy=%.1f</text>\n",
            midVx + 10.0, midVy, midVx + 10.0, midVy, dy);
}

static void atualizaBBoxForma(Forma *f, double *minX, double *minY, double *maxX, double *maxY)
{
    if (!f)
        return;
    TipoForma t = getFormaTipo(f);
    switch (t)
    {
    case TIPO_CIRCULO:
    {
        Circulo c = (Circulo)getFormaDados(f);
        double x = getCirculoX(c), y = getCirculoY(c), r = getCirculoRaio(c);
        double lx = x - r, rx = x + r, ty = y - r, by = y + r;
        if (lx < *minX)
        {
            *minX = lx;
        }
        if (rx > *maxX)
        {
            *maxX = rx;
        }
        if (ty < *minY)
        {
            *minY = ty;
        }
        if (by > *maxY)
        {
            *maxY = by;
        }
        break;
    }
    case TIPO_RETANGULO:
    {
        Retangulo r = (Retangulo)getFormaDados(f);
        double x = getRetanguloX(r), y = getRetanguloY(r);
        double w = getRetanguloLargura(r), h = getRetanguloAltura(r);
        if (x < *minX)
        {
            *minX = x;
        }
        if (y < *minY)
        {
            *minY = y;
        }
        if (x + w > *maxX)
        {
            *maxX = x + w;
        }
        if (y + h > *maxY)
        {
            *maxY = y + h;
        }
        break;
    }
    case TIPO_LINHA:
    {
        Linha l = (Linha)getFormaDados(f);
        double x1 = getLinhaX1(l), y1 = getLinhaY1(l), x2 = getLinhaX2(l), y2 = getLinhaY2(l);
        double lx = fmin(x1, x2), rx = fmax(x1, x2);
        double ty = fmin(y1, y2), by = fmax(y1, y2);
        if (lx < *minX)
        {
            *minX = lx;
        }
        if (rx > *maxX)
        {
            *maxX = rx;
        }
        if (ty < *minY)
        {
            *minY = ty;
        }
        if (by > *maxY)
        {
            *maxY = by;
        }
        break;
    }
    case TIPO_TEXTO:
    {
        Texto txt = (Texto)getFormaDados(f);
        double x = getTextoX(txt), y = getTextoY(txt);
        double fs = getTextoFontSize(txt);
        const char *s = getTextoConteudo(txt);
        double w = (s ? strlen(s) : 0) * (fs * 0.6);
        double h = fs;
        if (x < *minX)
        {
            *minX = x;
        }
        if (y - h < *minY)
        {
            *minY = y - h;
        }
        if (x + w > *maxX)
        {
            *maxX = x + w;
        }
        if (y > *maxY)
        {
            *maxY = y;
        }
        break;
    }
    default:
        break;
    }
}

static void calculaBBoxState(GameState state, double *outMinX, double *outMinY, double *outMaxX, double *outMaxY, int *outTemAlgo)
{
    double minX = DBL_MAX, minY = DBL_MAX, maxX = -DBL_MAX, maxY = -DBL_MAX;
    int tem = 0;
    // Não precisa mais considerar disparadores no bounding box
    // Arena (agora com FormaArena wrappers)
    Fila arena = getArena(state);
    if (arena && !filaVazia(arena))
    {
        Fila tmp = criaFila();
        while (!filaVazia(arena))
        {
            void *item = desenfileira(arena);
            if (item)
            {
                FormaArena fa = (FormaArena)item;
                Forma *f = getFormaArenaForma(fa);
                if (f)
                {
                    atualizaBBoxForma(f, &minX, &minY, &maxX, &maxY);
                    tem = 1;
                }
                // Considera tamb\u00e9m a posi\u00e7\u00e3o do disparador se anotada
                if (getFormaArenaAnotada(fa))
                {
                    double dx = getFormaArenaDisparadorX(fa);
                    double dy = getFormaArenaDisparadorY(fa);
                    if (dx < minX) minX = dx;
                    if (dx > maxX) maxX = dx;
                    if (dy < minY) minY = dy;
                    if (dy > maxY) maxY = dy;
                }
                enfileira(tmp, item);
            }
        }
        while (!filaVazia(tmp))
        {
            void *item = desenfileira(tmp);
            enfileira(arena, item);
        }
        destroiFila(tmp, NULL);
    }
    // Chão
    Fila chao = getChao(state);
    if (chao && !filaVazia(chao))
    {
        Fila tmp = criaFila();
        while (!filaVazia(chao))
        {
            Forma *f = (Forma *)desenfileira(chao);
            if (f)
            {
                atualizaBBoxForma(f, &minX, &minY, &maxX, &maxY);
                tem = 1;
                enfileira(tmp, f);
            }
        }
        while (!filaVazia(tmp))
        {
            Forma *f = (Forma *)desenfileira(tmp);
            enfileira(chao, f);
        }
        destroiFila(tmp, NULL);
    }
    if (outMinX)
    {
        *outMinX = minX;
    }
    if (outMinY)
    {
        *outMinY = minY;
    }
    if (outMaxX)
    {
        *outMaxX = maxX;
    }
    if (outMaxY)
    {
        *outMaxY = maxY;
    }
    if (outTemAlgo)
    {
        *outTemAlgo = tem;
    }
}

int svgGeraArquivoQry(const char *nomeArquivo, GameState state, int largura, int altura)
{
    if (!nomeArquivo || !state)
        return 1;
    // Calcula bounding box para ajustar canvas e aplicar margem/translate
    double minX, minY, maxX, maxY;
    int temAlgo = 0;
    calculaBBoxState(state, &minX, &minY, &maxX, &maxY, &temAlgo);
    const double margem = 20.0;
    double tx = 0.0, ty = 0.0;
    int W = largura, H = altura;
    if (temAlgo)
    {
        double compW = (maxX - minX) + 2 * margem;
        if (compW < 1)
            compW = largura;
        double compH = (maxY - minY) + 2 * margem;
        if (compH < 1)
            compH = altura;
        W = (int)fmax((double)largura, compW);
        H = (int)fmax((double)altura, compH);
        tx = margem - minX;
        ty = margem - minY;
    }
    FILE *arq = svgCriaArquivo(nomeArquivo, W, H);
    if (!arq)
        return 1;
    fprintf(arq, "  <!-- SVG gerado a partir do processamento do .qry -->\n");
    if (temAlgo)
    {
        fprintf(arq, "  <g transform=\"translate(%.2f, %.2f)\">\n", tx, ty);
    }
    desenhaDisparadores(arq, state);
    fprintf(arq, "  <!-- Formas na arena -->\n");
    Fila arena = getArena(state);
    if (arena && !filaVazia(arena))
    {
        Fila tmp = criaFila();
        while (!filaVazia(arena))
        {
            // Arena pode conter FormaArena wrappers
            void *item = desenfileira(arena);
            if (item)
            {
                // Tenta extrair como FormaArena
                FormaArena fa = (FormaArena)item;
                Forma *f = getFormaArenaForma(fa);
                
                if (f)
                {
                    // Desenha a forma
                    svgEscreveForma(arq, f);
                    
                    // Desenha anota\u00e7\u00f5es se marcada
                    if (getFormaArenaAnotada(fa))
                    {
                        desenhaAnotacaoTrajetoria(arq, f, 
                                                 getFormaArenaDisparadorX(fa),
                                                 getFormaArenaDisparadorY(fa));
                    }
                }
                enfileira(tmp, item);
            }
        }
        while (!filaVazia(tmp))
        {
            void *item = desenfileira(tmp);
            enfileira(arena, item);
        }
        destroiFila(tmp, NULL);
    }
    fprintf(arq, "  <!-- Formas no chão (opacidade reduzida) -->\n");
    Fila chao = getChao(state);
    if (chao && !filaVazia(chao))
    {
        Fila tmp = criaFila();
        while (!filaVazia(chao))
        {
            Forma *f = (Forma *)desenfileira(chao);
            if (f)
            {
                fprintf(arq, "  <g opacity=\"0.6\">\n");
                svgEscreveForma(arq, f);
                fprintf(arq, "  </g>\n");
                enfileira(tmp, f);
            }
        }
        while (!filaVazia(tmp))
        {
            Forma *f = (Forma *)desenfileira(tmp);
            enfileira(chao, f);
        }
        destroiFila(tmp, NULL);
    }
    if (temAlgo)
    {
        fprintf(arq, "  </g>\n");
    }
    svgFechaArquivo(arq);
    return 0;
}
